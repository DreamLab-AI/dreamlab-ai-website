# Data Protection and Privacy

**Last Updated:** 2026-02-28

This document covers private key lifecycle, encrypted communications, pod storage access control, and data protection measures in the DreamLab AI platform.

---

## Table of Contents

1. [Private Key Lifecycle](#private-key-lifecycle)
2. [Encrypted Direct Messages](#encrypted-direct-messages)
3. [Pod Storage Access Control](#pod-storage-access-control)
4. [No Server-Side Key Storage](#no-server-side-key-storage)
5. [Anti-SSRF Measures](#anti-ssrf-measures)
6. [Data Classification](#data-classification)
7. [Privacy Compliance](#privacy-compliance)

---

## Private Key Lifecycle

### Derivation

The secp256k1 private key is derived from the WebAuthn PRF extension output:

```
WebAuthn PRF output (32 bytes, HMAC-SHA-256 from authenticator)
  |
  v
HKDF(SHA-256, salt=[], info="nostr-secp256k1-v1")
  |
  v
32-byte secp256k1 private key (validated against curve order)
```

The PRF output is generated by the authenticator using a device-bound secret and the server-provided PRF salt. Neither the PRF output nor the device secret are accessible to the application or the server.

### In-Memory Storage

The private key is held exclusively in the auth store closure:

```typescript
// community-forum/src/lib/stores/auth.ts
let _privkeyMem: Uint8Array | null = null;
```

This variable is:

- **Not exported** from the module
- **Not written** to localStorage, sessionStorage, IndexedDB, cookies, or any external storage
- **Not transmitted** to any server (the server receives only the pubkey and signed events)
- **Accessible only** through closure-scoped functions within the auth store

### Zeroing on Page Unload

When the page is being unloaded, the key is overwritten with zeros:

```typescript
window.addEventListener('pagehide', () => {
  if (_privkeyMem) {
    _privkeyMem.fill(0);  // Overwrite all 32 bytes with 0x00
    _privkeyMem = null;    // Release the reference
  }
}, { once: true });
```

**Why `pagehide` and not `visibilitychange`**: Using `visibilitychange` would clear the key every time the user switches tabs, forcing re-authentication on each return. `pagehide` fires only when the page is actually being unloaded (navigation, tab close, window close).

### Re-Derivation

On the next login, the user authenticates with the same passkey. Because the same credential and same PRF salt are used, the authenticator produces the same PRF output, and HKDF derives the same private key. The key lifecycle restarts.

### Summary

| Phase | Location | Duration |
|-------|----------|----------|
| Derived | Browser memory (closure) | Instantaneous |
| Active | `_privkeyMem` in auth store closure | Until pagehide |
| Zeroed | Overwritten with 0x00 bytes | On pagehide |
| Re-derived | Same passkey + same PRF salt | On next login |

---

## Encrypted Direct Messages

### NIP-44 v2 Encryption

Direct messages use NIP-44 v2 (XChaCha20-Poly1305 with HMAC-SHA256):

- **Cipher**: XChaCha20 stream cipher (256-bit key, 192-bit nonce)
- **MAC**: Poly1305 (128-bit authentication tag)
- **Mode**: AEAD (Authenticated Encryption with Associated Data)
- **Key Derivation**: ECDH between sender and recipient keys, then HKDF-SHA256

The relay stores encrypted DM content as opaque blobs. It cannot decrypt messages because it does not possess any user's private key.

### NIP-17/59 Gift Wrapping

DMs are additionally wrapped using NIP-59 gift wrap for metadata protection:

```
Gift Wrap (kind 1059)
  pubkey: random ephemeral key (not the sender)
  created_at: randomised timestamp (+/- 2 days)
  content: encrypted seal
    |
    v
Seal (kind 13)
  pubkey: real sender
  content: JSON rumor
  sig: Schnorr signature
    |
    v
Rumor (kind 14, unsigned)
  content: NIP-44 encrypted message
  created_at: actual timestamp
```

**Properties**:

- The relay cannot identify the sender (the gift wrap uses an ephemeral pubkey)
- The relay cannot determine the actual timestamp (randomised within a 4-day window)
- Only the recipient can unwrap and decrypt
- Ephemeral keys provide plausible deniability

---

## Pod Storage Access Control

### WAC (Web Access Control) on JSS Pods

Each user's Solid pod is provisioned with access control based on the WAC specification:

| Principal | Access |
|-----------|--------|
| **Owner** (Nostr pubkey) | Full Control (Read, Write, Append, Control) |
| **Authenticated agents** (`acl:AuthenticatedAgent`) | Read-only |
| **Public** (unauthenticated) | No access |

### ACL Document Structure

ACL rules are stored as JSON-LD documents within the pod:

```json
{
  "@context": { "acl": "http://www.w3.org/ns/auth/acl#" },
  "@graph": [
    {
      "@id": "#owner",
      "@type": "acl:Authorization",
      "acl:agent": "did:nostr:<pubkey>",
      "acl:accessTo": "<resource>",
      "acl:mode": ["acl:Read", "acl:Write", "acl:Append", "acl:Control"]
    },
    {
      "@id": "#authenticated",
      "@type": "acl:Authorization",
      "acl:agentClass": "acl:AuthenticatedAgent",
      "acl:accessTo": "<resource>",
      "acl:mode": ["acl:Read"]
    }
  ]
}
```

### WAC Evaluator (Planned for Cloudflare Workers)

The planned Cloudflare Workers migration includes a custom WAC evaluator:

- **JSON-LD ACL parsing**: No RDF library dependencies
- **NIP-98 identity resolution**: Maps `Authorization: Nostr <token>` to `did:nostr:<pubkey>`
- **Access decision**: Evaluates ACL rules against the authenticated identity and requested access mode
- **Estimated size**: ~200 lines, zero external dependencies

### Cloud Storage Persistence

Pod data is stored on a Google Cloud Storage volume mount (`dreamlab-pods` bucket) attached to the JSS Cloud Run service:

```
--add-volume name=dreamlab-pods,type=cloud-storage,bucket=dreamlab-pods,mount-path=/data/pods
```

This provides persistence across container restarts, unlike ephemeral container storage.

---

## No Server-Side Key Storage

### What the Server Stores

| Data | Table | Purpose |
|------|-------|---------|
| Credential ID | `webauthn_credentials` | WebAuthn assertion matching |
| Public key bytes | `webauthn_credentials` | WebAuthn signature verification |
| PRF salt (32 bytes) | `webauthn_credentials.prf_salt` | Returned to client for PRF evaluation |
| Counter | `webauthn_credentials.counter` | Replay prevention |
| Pubkey (hex) | `webauthn_credentials.pubkey` | Identity lookup |
| DID | `webauthn_credentials.did_nostr` | `did:nostr:<pubkey>` |
| WebID | `webauthn_credentials.webid` | Solid pod profile URL |
| Pod URL | `webauthn_credentials.pod_url` | Solid pod base URL |

### What the Server Never Stores

- **Private keys**: The secp256k1 private key is never transmitted to the server.
- **PRF output**: The WebAuthn PRF result stays in the browser. Only the PRF salt (input to the PRF, not the output) is stored server-side.
- **Session tokens**: There are no server-side sessions. Every request is independently authenticated via NIP-98.
- **Passwords**: The CSS pod password is generated once during provisioning and never persisted (it is a random string that exists only during the provisioning flow).

### Database Breach Impact

If the `webauthn_credentials` table is fully compromised:

- **Cannot derive private keys**: PRF output requires the physical authenticator's device-bound secret.
- **Cannot sign events**: Schnorr signatures require the private key.
- **Cannot access encrypted DMs**: NIP-44 decryption requires the private key.
- **Cannot impersonate users**: WebAuthn assertions require the physical authenticator.
- **Can see**: pubkeys, DIDs, WebIDs, pod URLs, credential metadata. These are all semi-public information.

---

## Anti-SSRF Measures

### RP_ORIGIN URL Reconstruction

The auth-api reconstructs request URLs from the `RP_ORIGIN` environment variable instead of trusting request headers:

```typescript
// community-forum/services/auth-api/src/nip98.ts
const rpOrigin = process.env.RP_ORIGIN || '';
const baseOrigin = rpOrigin.replace(/\/$/, '');
const fullUrl = `${baseOrigin}${req.originalUrl}`;
```

This prevents an attacker from:

1. Spoofing `Host` or `X-Forwarded-Host` headers
2. Crafting a NIP-98 token for a different URL
3. Tricking the server into accepting the token by matching the spoofed header

### JSS Client URL Validation

The JSS client validates all URLs returned by the Community Solid Server:

```typescript
function validateCssUrl(raw: unknown, label: string): string {
  const parsed = new URL(raw as string);
  if (parsed.protocol !== 'https:' && parsed.protocol !== 'http:') {
    throw new Error(`Non-http(s) scheme for ${label}`);
  }
  if (parsed.host !== expectedHost) {
    throw new Error(`Unexpected host for ${label}`);
  }
  return parsed.toString();
}
```

This prevents a compromised or malicious CSS instance from redirecting the auth-api to internal services.

### Path Traversal Prevention

WebAuthn registration rejects `webId` values containing `..` or `%2e%2e`:

```typescript
if (rawClientWebId.includes('..') || /%2e%2e/i.test(rawClientWebId)) {
  res.status(400).json({ error: 'webId contains invalid path sequences' });
  return;
}
```

---

## Data Classification

| Level | Data Types | Storage | Encryption |
|-------|-----------|---------|-----------|
| **Critical** | Private key (Uint8Array) | Memory closure only | N/A (never stored) |
| **High** | DM content | Relay database (encrypted) | NIP-44 v2 + NIP-59 gift wrap |
| **Medium** | PRF salt, WebAuthn credentials | PostgreSQL | At rest (Cloud SQL) |
| **Low** | Public channel messages, reactions | Relay database | None (public by design) |
| **Public** | Pubkeys, profiles, metadata | Relay database, pods | None |

### Data Handling Rules

1. **Critical data** (private key): Never logged, never transmitted, never stored. Zeroed on pagehide.
2. **High sensitivity** (DM content): End-to-end encrypted. Relay stores only ciphertext. TLS in transit.
3. **Medium sensitivity** (credentials): Protected by Cloud SQL encryption at rest and TLS in transit. Access restricted via IAM.
4. **Low/Public**: Standard security practices. Users control deletion via NIP-09 events.

---

## Privacy Compliance

### GDPR

| Right | Implementation |
|-------|---------------|
| **Right to access** | Users can export all Nostr events signed by their pubkey |
| **Right to rectification** | Users can publish updated metadata (kind 0) events |
| **Right to erasure** | Users can publish NIP-09 deletion events; compliant relays honour them |
| **Right to portability** | Nostr protocol is inherently portable; events can be exported and imported to any compatible client |
| **Right to object** | Users can disconnect from the relay at any time |

### Key Privacy Properties

- **Self-custodial identity**: The user controls their cryptographic identity. DreamLab cannot lock users out or revoke access to their identity.
- **No password database**: There are no passwords to breach. Authentication is based on cryptographic proof of key possession.
- **Minimal server-side data**: The server stores only what is necessary for WebAuthn ceremony replay (credentials, counters, PRF salts) and identity resolution (pubkey, DID, WebID).
- **Decentralised data**: Nostr events can be replicated across multiple relays. Users are not locked into DreamLab's relay.

---

## Related Documentation

- [Security Overview](./SECURITY_OVERVIEW.md)
- [Authentication](./AUTHENTICATION.md)
- [Auth API Reference](../api/AUTH_API.md)
- [Deployment: Cloud Services](../deployment/CLOUD_SERVICES.md)

---

*This document is version-controlled. Last major revision: 2026-02-28.*
