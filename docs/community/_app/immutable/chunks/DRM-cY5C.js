import{u as p,n as f}from"./BVL4R8vY.js";const I=256,u=12,y=16;class i extends Error{constructor(e,t){super(e),this.code=t,this.name="ImageEncryptionError"}}function w(){return typeof crypto<"u"&&typeof crypto.subtle<"u"&&typeof crypto.getRandomValues<"u"}async function d(){if(!w())throw new i("Web Crypto API not available","CRYPTO_UNAVAILABLE");return crypto.getRandomValues(new Uint8Array(32))}async function E(r){const e=new ArrayBuffer(r.length);return new Uint8Array(e).set(r),crypto.subtle.importKey("raw",e,{name:"AES-GCM",length:I},!1,["encrypt","decrypt"])}async function g(r,e){if(!w())throw new i("Web Crypto API not available","CRYPTO_UNAVAILABLE");if(e.length!==32)throw new i("Key must be 32 bytes (256 bits)","INVALID_KEY_LENGTH");const t=crypto.getRandomValues(new Uint8Array(u)),n=crypto.getRandomValues(new Uint8Array(y)),o=await E(e),c=await r.arrayBuffer(),a=await crypto.subtle.encrypt({name:"AES-GCM",iv:t},o,c),s=new Uint8Array(n.length+t.length+a.byteLength);return s.set(n,0),s.set(t,n.length),s.set(new Uint8Array(a),n.length+t.length),{encryptedBlob:s.buffer,iv:h(t.buffer),salt:h(n.buffer)}}async function A(r,e){if(!w())throw new i("Web Crypto API not available","CRYPTO_UNAVAILABLE");if(e.length!==32)throw new i("Key must be 32 bytes (256 bits)","INVALID_KEY_LENGTH");const t=new Uint8Array(r);t.slice(0,y);const n=t.slice(y,y+u),o=t.slice(y+u),c=await E(e);try{const a=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},c,o);return new Blob([a])}catch{throw new i("Decryption failed - invalid key or corrupted data","DECRYPTION_FAILED")}}async function b(r,e,t){if(!e||e.length===0)throw new i("At least one recipient is required","NO_RECIPIENTS");const n=p.bytesToHex(r),o=[],c=[];for(const a of e)try{if(!/^[0-9a-f]{64}$/i.test(a))throw new Error("Invalid pubkey format");const s=f.v2.utils.getConversationKey(p.hexToBytes(t),a),l=f.v2.encrypt(n,s);o.push({pubkey:a,encryptedKey:l})}catch(s){const l=s instanceof Error?s.message:"Unknown error";c.push({pubkey:a,error:l})}if(o.length===0&&c.length>0)throw new i(`Failed to encrypt key for all recipients: ${JSON.stringify(c)}`,"KEY_ENCRYPTION_FAILED");return o}async function m(r,e,t){try{if(!/^[0-9a-f]{64}$/i.test(e))throw new i("Invalid sender pubkey format","INVALID_SENDER_PUBKEY");if(!/^[0-9a-f]{64}$/i.test(t))throw new i("Invalid recipient privkey format","INVALID_RECIPIENT_PRIVKEY");const n=f.v2.utils.getConversationKey(p.hexToBytes(t),e),o=f.v2.decrypt(r,n);return p.hexToBytes(o)}catch(n){throw n instanceof i?n:new i("Failed to decrypt image key","KEY_DECRYPTION_FAILED")}}async function L(r,e,t){const n=await d(),{encryptedBlob:o,iv:c,salt:a}=await g(r,n),s=await b(n,e,t);return{encryptedBlob:o,iv:c,salt:a,recipientKeys:s}}async function N(r,e,t,n){const o=await m(e,t,n);return A(r,o)}function h(r){const e=new Uint8Array(r);let t="";for(let n=0;n<e.byteLength;n++)t+=String.fromCharCode(e[n]);return btoa(t)}export{N as d,L as e};
