import{D as k}from"./BVL4R8vY.js";class f extends k{messages;channels;users;deletions;relays;searchIndex;searchHistory;embeddings;metadata;constructor(){super("MinimoomaNoirDB"),this.version(1).stores({messages:"id, channelId, pubkey, created_at, deleted, [channelId+created_at]",channels:"id, creatorPubkey, created_at, isPrivate, isEncrypted",users:"pubkey, cached_at",deletions:"id, deletedEventId, channelId, deleterPubkey, created_at",relays:"url, connected, lastConnected"}),this.version(2).stores({messages:"id, channelId, pubkey, created_at, deleted, [channelId+created_at]",channels:"id, creatorPubkey, created_at, isPrivate, isEncrypted",users:"pubkey, cached_at",deletions:"id, deletedEventId, channelId, deleterPubkey, created_at",relays:"url, connected, lastConnected",searchIndex:"id, messageId, channelId, authorPubkey, timestamp, *tokens",searchHistory:"++id, timestamp"}),this.version(3).stores({messages:"id, channelId, pubkey, created_at, deleted, [channelId+created_at]",channels:"id, creatorPubkey, created_at, isPrivate, isEncrypted",users:"pubkey, cached_at",deletions:"id, deletedEventId, channelId, deleterPubkey, created_at",relays:"url, connected, lastConnected",searchIndex:"id, messageId, channelId, authorPubkey, timestamp, *tokens",searchHistory:"++id, timestamp",embeddings:"key, version",metadata:"key"})}async clearAll(){await this.messages.clear(),await this.channels.clear(),await this.users.clear(),await this.deletions.clear(),await this.relays.clear()}async getStorageEstimate(){if("storage"in navigator&&"estimate"in navigator.storage){const e=await navigator.storage.estimate(),s=e.usage||0,t=e.quota||0;return{used:s,quota:t,percentage:t>0?s/t*100:0}}return{used:0,quota:0,percentage:0}}async getTableCounts(){return{messages:await this.messages.count(),channels:await this.channels.count(),users:await this.users.count(),deletions:await this.deletions.count(),searchIndex:await this.searchIndex.count(),searchHistory:await this.searchHistory.count()}}async pruneOldCache(e={}){const{maxMessageAgeDays:s=3,maxMessagesPerChannel:t=1e3,maxCachedUsers:a=500,maxSearchIndexAgeDays:o=7,forceAggressive:y=!1}=e,r={messages:0,users:0,deletions:0,searchIndex:0},u=await this.getStorageEstimate(),d=y||u.percentage>80,h=Date.now()/1e3,g=h-s*24*60*60,w=h-o*24*60*60,m=h-(d?1:7)*24*60*60;r.messages+=await this.messages.where("created_at").below(g).delete();const p=await this.channels.toArray();for(const n of p)if(await this.messages.where("channelId").equals(n.id).count()>t){const i=await this.messages.where("channelId").equals(n.id).reverse().offset(t).toArray();if(i.length>0){const l=i.map(b=>b.id);await this.messages.bulkDelete(l),r.messages+=l.length,await this.searchIndex.where("messageId").anyOf(l).delete()}}if(await this.users.count()>a||d){r.users+=await this.users.where("cached_at").below(m).delete();const n=await this.users.count();if(n>a){const c=await this.users.orderBy("cached_at").limit(n-a).toArray();await this.users.bulkDelete(c.map(i=>i.pubkey)),r.users+=c.length}}if(r.deletions+=await this.deletions.where("created_at").below(h-(d?3:7)*24*60*60).delete(),r.searchIndex+=await this.searchIndex.where("timestamp").below(w).delete(),d){const n=await this.searchHistory.count();if(n>20){const c=await this.searchHistory.orderBy("timestamp").limit(n-20).toArray();await this.searchHistory.bulkDelete(c.map(i=>i.id))}}const I=await this.getStorageEstimate();return{pruned:r,storageFreed:u.used-I.used}}async autoMaintenance(){const e=await this.getStorageEstimate();e.percentage>90?(console.warn(`[DB] Storage at ${e.percentage.toFixed(1)}% - running aggressive cleanup`),await this.pruneOldCache({forceAggressive:!0})):e.percentage>70&&(console.info(`[DB] Storage at ${e.percentage.toFixed(1)}% - running standard cleanup`),await this.pruneOldCache())}async getChannelMessagesWithAuthors(e){const s=await this.messages.where("channelId").equals(e).and(a=>!a.deleted).sortBy("created_at");return await Promise.all(s.map(async a=>{const o=await this.users.get(a.pubkey);return{...a,author:o||null}}))}async markMessageDeleted(e){await this.messages.update(e,{deleted:!0})}async getChannel(e){return await this.channels.get(e)}async getUser(e){return await this.users.get(e)}async cacheUser(e){await this.users.put({...e,cached_at:Date.now()/1e3})}async isMessageDeleted(e){return await this.deletions.get(e)!==void 0}async addDeletion(e){await this.deletions.put(e),await this.markMessageDeleted(e.deletedEventId)}async updateRelay(e,s){await this.relays.get(e)?await this.relays.update(e,s):await this.relays.put({url:e,connected:!1,lastConnected:null,lastError:null,subscriptions:[],...s})}async exportMessages(e){return e?await this.messages.where("channelId").equals(e).toArray():await this.messages.toArray()}async importMessages(e){await this.messages.bulkPut(e)}tokenize(e){return e.toLowerCase().replace(/[^\w\s]/g," ").split(/\s+/).filter(s=>s.length>1).filter(s=>!this.isStopWord(s))}isStopWord(e){return new Set(["the","a","an","and","or","but","in","on","at","to","for","of","with","is","was","are","were","be","been","being","have","has","had","do","does","did","will","would","should","could","may","might","must","can","this","that","these","those"]).has(e)}async indexMessage(e){if(e.deleted)return;const s=this.tokenize(e.content),t={id:`idx_${e.id}`,messageId:e.id,channelId:e.channelId,content:e.content,authorPubkey:e.pubkey,timestamp:e.created_at,tokens:s};await this.searchIndex.put(t)}async bulkIndexMessages(e){const s=e.filter(t=>!t.deleted).map(t=>{const a=this.tokenize(t.content);return{id:`idx_${t.id}`,messageId:t.id,channelId:t.channelId,content:t.content,authorPubkey:t.pubkey,timestamp:t.created_at,tokens:a}});await this.searchIndex.bulkPut(s)}async removeFromIndex(e){await this.searchIndex.delete(`idx_${e}`)}async clearSearchIndex(){await this.searchIndex.clear()}async addSearchHistory(e,s){await this.searchHistory.add({query:e,timestamp:Date.now()/1e3,resultCount:s});const t=await this.searchHistory.count();if(t>50){const a=await this.searchHistory.orderBy("timestamp").limit(t-50).toArray();await this.searchHistory.bulkDelete(a.map(o=>o.id))}}async getSearchHistory(e=10){return await this.searchHistory.orderBy("timestamp").reverse().limit(e).toArray()}async clearSearchHistory(){await this.searchHistory.clear()}}const C=new f;export{C as d};
