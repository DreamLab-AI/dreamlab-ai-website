import{h as p,j as g,k as y,N as _}from"./CHLmt3N8.js";import{w as f}from"./Box6chXe.js";import{N as h,T as l}from"./C_zicc2g.js";var w=(s=>(s.Disconnected="disconnected",s.Connecting="connecting",s.Connected="connected",s.AuthRequired="auth-required",s.Authenticating="authenticating",s.Authenticated="authenticated",s.AuthFailed="auth-failed",s.Error="error",s))(w||{});class b{_ndk=null;_signer=null;_activeSubscriptions=new Map;_connectionState=f({state:"disconnected",timestamp:Date.now(),authenticated:!1});_cacheAdapter=null;get ndk(){return this._ndk}get connectionState(){return this._connectionState}updateState(e,r,n,t=!1){this._connectionState.set({state:e,relay:r,error:n,timestamp:Date.now(),authenticated:t})}async initializeNDK(e,r){this._signer=new p(e),this._cacheAdapter||(this._cacheAdapter=new g({dbName:h.cache.name}));const n=new y({explicitRelayUrls:[r],signer:this._signer,cacheAdapter:this._cacheAdapter??void 0,enableOutboxModel:!1});return h.enableDebug&&(n.pool.on("relay:connect",t=>{console.log(`[NDK] Connected to relay: ${t.url}`)}),n.pool.on("relay:disconnect",t=>{console.log(`[NDK] Disconnected from relay: ${t.url}`)}),n.pool.on("relay:auth",(t,i)=>{console.log(`[NDK] AUTH challenge from ${t.url}: ${i}`)})),n}async handleAuthChallenge(e,r){if(!this._signer)throw new Error("No signer available for authentication");try{this.updateState("authenticating",e.url);const n=await this._signer.user(),t=new _(this._ndk??void 0);t.kind=22242,t.tags=[["relay",e.url],["challenge",r]],t.content="",t.pubkey=n.pubkey,t.created_at=Math.floor(Date.now()/1e3),await t.sign(this._signer);const i=new Promise((c,d)=>{setTimeout(()=>d(new Error("AUTH timeout")),l.auth)}),o=new Promise(c=>{setTimeout(()=>c(!0),1e3)}),u=await Promise.race([o,i]);return u&&this.updateState("authenticated",e.url,void 0,!0),u}catch(n){const t=n instanceof Error?n.message:"Unknown error";throw this.updateState("auth-failed",e.url,t),n}}async connectRelay(e,r){try{this.updateState("connecting",e),this._ndk&&await this.disconnectRelay(),this._ndk=await this.initializeNDK(r,e);const n=new Promise((u,c)=>{setTimeout(()=>c(new Error("Connection timeout")),l.connect)}),t=this._ndk.connect();await Promise.race([t,n]);const i=Array.from(this._ndk.pool.relays.values())[0];if(!i)throw new Error("No relay connected");i.on("auth",async u=>{this.updateState("auth-required",i.url);try{await this.handleAuthChallenge(i,u)}catch(c){console.error("[NDK] AUTH failed:",c)}});const o=i.connectivity.status>=5?"connected":"disconnected";return this.updateState(o,e,void 0,!1),{state:o,relay:e,timestamp:Date.now(),authenticated:!1}}catch(n){const t=n instanceof Error?n.message:"Connection failed";throw this.updateState("error",e,t),n}}async publishEvent(e){if(!this._ndk)throw new Error("NDK not initialized. Call connectRelay first.");if(!this._signer)throw new Error("No signer available. Call connectRelay first.");try{e.ndk=this._ndk,e.sig||await e.sign(this._signer);const r=new Promise((i,o)=>{setTimeout(()=>o(new Error("Publish timeout")),l.publish)}),n=e.publish();return(await Promise.race([n,r])).size>0}catch(r){throw console.error("[NDK] Publish failed:",r),r}}subscribe(e,r){if(!this._ndk)throw new Error("NDK not initialized. Call connectRelay first.");const n=Array.isArray(e)?e:[e],t=this._ndk.subscribe(n,{closeOnEose:r?.closeOnEose??!1,groupable:r?.groupable??!0,subId:r?.subId}),i=r?.subId??`sub_${Date.now()}_${Math.random().toString(36).slice(2)}`;return this._activeSubscriptions.set(i,t),t.on("close",()=>{this._activeSubscriptions.delete(i)}),t}getSubscription(e){return this._activeSubscriptions.get(e)}closeSubscription(e){const r=this._activeSubscriptions.get(e);return r?(r.stop(),this._activeSubscriptions.delete(e),!0):!1}getActiveSubscriptions(){return new Map(this._activeSubscriptions)}async disconnectRelay(){try{if(this._activeSubscriptions.forEach(e=>{e.stop()}),this._activeSubscriptions.clear(),this._ndk){for(const e of this._ndk.pool.relays.values())e.disconnect();this._ndk=null}this._signer=null,this.updateState("disconnected")}catch(e){throw console.error("[NDK] Disconnect error:",e),e}}isConnected(){if(!this._ndk)return!1;for(const e of this._ndk.pool.relays.values())if(e.connectivity.status>=5)return!0;return!1}async getCurrentUser(){if(!this._signer)return null;try{return await this._signer.user()}catch{return null}}getRelayUrls(){return this._ndk?Array.from(this._ndk.pool.relays.values()).map(e=>e.url):[]}}const a=new b,S=()=>a.ndk,D=a.connectionState,N=(s,e)=>a.connectRelay(s,e),A=s=>a.publishEvent(s),E=(s,e)=>a.subscribe(s,e),R=()=>a.isConnected(),K=()=>a.getRelayUrls(),P=async()=>{if(a.getRelayUrls().length===0){console.warn("[Relay] No relay to reconnect to");return}await a.disconnectRelay()};export{w as ConnectionState,N as connectRelay,D as connectionState,a as default,K as getRelayUrls,R as isConnected,S as ndk,A as publishEvent,P as reconnectRelay,E as subscribe};
