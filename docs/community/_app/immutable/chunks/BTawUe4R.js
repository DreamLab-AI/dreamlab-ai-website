import{h as p,j as y,k as _,N as g}from"./Do1Y_WLx.js";import{w as f}from"./DjSB8mDa.js";import{N as h,T as u}from"./C_zicc2g.js";class w{_ndk=null;_signer=null;_activeSubscriptions=new Map;_connectionState=f({state:"disconnected",timestamp:Date.now(),authenticated:!1});_cacheAdapter=null;get ndk(){return this._ndk}get connectionState(){return this._connectionState}updateState(e,r,n,t=!1){this._connectionState.set({state:e,relay:r,error:n,timestamp:Date.now(),authenticated:t})}async initializeNDK(e,r){this._signer=new p(e),this._cacheAdapter||(this._cacheAdapter=new y({dbName:h.cache.name}));const n=new _({explicitRelayUrls:[r],signer:this._signer,cacheAdapter:this._cacheAdapter??void 0,enableOutboxModel:!1});return h.enableDebug&&(n.pool.on("relay:connect",t=>{console.log(`[NDK] Connected to relay: ${t.url}`)}),n.pool.on("relay:disconnect",t=>{console.log(`[NDK] Disconnected from relay: ${t.url}`)}),n.pool.on("relay:auth",(t,s)=>{console.log(`[NDK] AUTH challenge from ${t.url}: ${s}`)})),n}async handleAuthChallenge(e,r){if(!this._signer)throw new Error("No signer available for authentication");try{this.updateState("authenticating",e.url);const n=await this._signer.user(),t=new g(this._ndk??void 0);t.kind=22242,t.tags=[["relay",e.url],["challenge",r]],t.content="",t.pubkey=n.pubkey,t.created_at=Math.floor(Date.now()/1e3),await t.sign(this._signer);const s=new Promise((c,d)=>{setTimeout(()=>d(new Error("AUTH timeout")),u.auth)}),a=new Promise(c=>{setTimeout(()=>c(!0),1e3)}),l=await Promise.race([a,s]);return l&&this.updateState("authenticated",e.url,void 0,!0),l}catch(n){const t=n instanceof Error?n.message:"Unknown error";throw this.updateState("auth-failed",e.url,t),n}}async connectRelay(e,r){try{this.updateState("connecting",e),this._ndk&&await this.disconnectRelay(),this._ndk=await this.initializeNDK(r,e);const n=new Promise((l,c)=>{setTimeout(()=>c(new Error("Connection timeout")),u.connect)}),t=this._ndk.connect();await Promise.race([t,n]);const s=Array.from(this._ndk.pool.relays.values())[0];if(!s)throw new Error("No relay connected");s.on("auth",async l=>{this.updateState("auth-required",s.url);try{await this.handleAuthChallenge(s,l)}catch(c){console.error("[NDK] AUTH failed:",c)}});const a=s.connectivity.status>=5?"connected":"disconnected";return this.updateState(a,e,void 0,!1),{state:a,relay:e,timestamp:Date.now(),authenticated:!1}}catch(n){const t=n instanceof Error?n.message:"Connection failed";throw this.updateState("error",e,t),n}}async publishEvent(e){if(!this._ndk)throw new Error("NDK not initialized. Call connectRelay first.");if(!this._signer)throw new Error("No signer available. Call connectRelay first.");try{e.ndk=this._ndk,e.sig||await e.sign(this._signer);const r=new Promise((s,a)=>{setTimeout(()=>a(new Error("Publish timeout")),u.publish)}),n=e.publish();return(await Promise.race([n,r])).size>0}catch(r){throw console.error("[NDK] Publish failed:",r),r}}subscribe(e,r){if(!this._ndk)throw new Error("NDK not initialized. Call connectRelay first.");const n=Array.isArray(e)?e:[e],t=this._ndk.subscribe(n,{closeOnEose:r?.closeOnEose??!1,groupable:r?.groupable??!0,subId:r?.subId}),s=r?.subId??`sub_${Date.now()}_${Math.random().toString(36).slice(2)}`;return this._activeSubscriptions.set(s,t),t.on("close",()=>{this._activeSubscriptions.delete(s)}),t}getSubscription(e){return this._activeSubscriptions.get(e)}closeSubscription(e){const r=this._activeSubscriptions.get(e);return r?(r.stop(),this._activeSubscriptions.delete(e),!0):!1}getActiveSubscriptions(){return new Map(this._activeSubscriptions)}async disconnectRelay(){try{if(this._activeSubscriptions.forEach(e=>{e.stop()}),this._activeSubscriptions.clear(),this._ndk){for(const e of this._ndk.pool.relays.values())e.disconnect();this._ndk=null}this._signer=null,this.updateState("disconnected")}catch(e){throw console.error("[NDK] Disconnect error:",e),e}}isConnected(){if(!this._ndk)return!1;for(const e of this._ndk.pool.relays.values())if(e.connectivity.status>=5)return!0;return!1}async getCurrentUser(){if(!this._signer)return null;try{return await this._signer.user()}catch{return null}}getRelayUrls(){return this._ndk?Array.from(this._ndk.pool.relays.values()).map(e=>e.url):[]}}const i=new w,k=()=>i.ndk;i.connectionState;const v=(o,e)=>i.connectRelay(o,e),D=o=>i.publishEvent(o),N=(o,e)=>i.subscribe(o,e),E=()=>i.isConnected(),A=()=>i.getRelayUrls(),R=async()=>{if(i.getRelayUrls().length===0){console.warn("[Relay] No relay to reconnect to");return}await i.disconnectRelay()};export{v as connectRelay,i as default,A as getRelayUrls,E as isConnected,k as ndk,D as publishEvent,R as reconnectRelay,N as subscribe};
