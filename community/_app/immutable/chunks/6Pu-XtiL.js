import{D as u}from"./DxD0Wn3l.js";class f extends u{messages;channels;users;deletions;relays;searchIndex;searchHistory;embeddings;metadata;constructor(){super("MinimoomaNoirDB"),this.version(1).stores({messages:"id, channelId, pubkey, created_at, deleted, [channelId+created_at]",channels:"id, creatorPubkey, created_at, isPrivate, isEncrypted",users:"pubkey, cached_at",deletions:"id, deletedEventId, channelId, deleterPubkey, created_at",relays:"url, connected, lastConnected"}),this.version(2).stores({messages:"id, channelId, pubkey, created_at, deleted, [channelId+created_at]",channels:"id, creatorPubkey, created_at, isPrivate, isEncrypted",users:"pubkey, cached_at",deletions:"id, deletedEventId, channelId, deleterPubkey, created_at",relays:"url, connected, lastConnected",searchIndex:"id, messageId, channelId, authorPubkey, timestamp, *tokens",searchHistory:"++id, timestamp"}),this.version(3).stores({messages:"id, channelId, pubkey, created_at, deleted, [channelId+created_at]",channels:"id, creatorPubkey, created_at, isPrivate, isEncrypted",users:"pubkey, cached_at",deletions:"id, deletedEventId, channelId, deleterPubkey, created_at",relays:"url, connected, lastConnected",searchIndex:"id, messageId, channelId, authorPubkey, timestamp, *tokens",searchHistory:"++id, timestamp",embeddings:"key, version",metadata:"key"})}async clearAll(){await this.messages.clear(),await this.channels.clear(),await this.users.clear(),await this.deletions.clear(),await this.relays.clear()}async getStorageEstimate(){if("storage"in navigator&&"estimate"in navigator.storage){const e=await navigator.storage.estimate(),a=e.usage||0,t=e.quota||0;return{used:a,quota:t,percentage:t>0?a/t*100:0}}return{used:0,quota:0,percentage:0}}async getTableCounts(){return{messages:await this.messages.count(),channels:await this.channels.count(),users:await this.users.count(),deletions:await this.deletions.count(),searchIndex:await this.searchIndex.count(),searchHistory:await this.searchHistory.count()}}async pruneOldCache(e={}){const{maxMessageAgeDays:a=3,maxMessagesPerChannel:t=1e3,maxCachedUsers:s=500,maxSearchIndexAgeDays:o=7,forceAggressive:g=!1}=e,i={messages:0,users:0,deletions:0,searchIndex:0},y=await this.getStorageEstimate(),d=g||y.percentage>80,h=Date.now()/1e3,w=h-a*24*60*60,m=h-o*24*60*60,p=h-(d?1:7)*24*60*60;i.messages+=await this.messages.where("created_at").below(w).delete();const I=await this.channels.toArray();for(const n of I)if(await this.messages.where("channelId").equals(n.id).count()>t){const r=await this.messages.where("[channelId+created_at]").between([n.id,u.minKey],[n.id,u.maxKey]).reverse().offset(t).toArray();if(r.length>0){const l=r.map(k=>k.id);await this.messages.bulkDelete(l),i.messages+=l.length,await this.searchIndex.where("messageId").anyOf(l).delete()}}if(await this.users.count()>s||d){i.users+=await this.users.where("cached_at").below(p).delete();const n=await this.users.count();if(n>s){const c=await this.users.orderBy("cached_at").limit(n-s).toArray();await this.users.bulkDelete(c.map(r=>r.pubkey)),i.users+=c.length}}if(i.deletions+=await this.deletions.where("created_at").below(h-(d?3:7)*24*60*60).delete(),i.searchIndex+=await this.searchIndex.where("timestamp").below(m).delete(),d){const n=await this.searchHistory.count();if(n>20){const c=await this.searchHistory.orderBy("timestamp").limit(n-20).toArray();await this.searchHistory.bulkDelete(c.map(r=>r.id))}}const b=await this.getStorageEstimate();return{pruned:i,storageFreed:y.used-b.used}}async autoMaintenance(){const e=await this.getStorageEstimate();e.percentage>90?(console.warn(`[DB] Storage at ${e.percentage.toFixed(1)}% - running aggressive cleanup`),await this.pruneOldCache({forceAggressive:!0})):e.percentage>70&&(console.info(`[DB] Storage at ${e.percentage.toFixed(1)}% - running standard cleanup`),await this.pruneOldCache())}async getChannelMessagesWithAuthors(e){const a=await this.messages.where("channelId").equals(e).and(s=>!s.deleted).sortBy("created_at");return await Promise.all(a.map(async s=>{const o=await this.users.get(s.pubkey);return{...s,author:o||null}}))}async markMessageDeleted(e){await this.messages.update(e,{deleted:!0})}async getChannel(e){return await this.channels.get(e)}async getUser(e){return await this.users.get(e)}async cacheUser(e){await this.users.put({...e,cached_at:Date.now()/1e3})}async isMessageDeleted(e){return await this.deletions.get(e)!==void 0}async addDeletion(e){await this.deletions.put(e),await this.markMessageDeleted(e.deletedEventId)}async updateRelay(e,a){await this.relays.get(e)?await this.relays.update(e,a):await this.relays.put({url:e,connected:!1,lastConnected:null,lastError:null,subscriptions:[],...a})}async exportMessages(e){return e?await this.messages.where("channelId").equals(e).toArray():await this.messages.toArray()}async importMessages(e){await this.messages.bulkPut(e)}tokenize(e){return e.toLowerCase().replace(/[^\w\s]/g," ").split(/\s+/).filter(a=>a.length>1).filter(a=>!this.isStopWord(a))}isStopWord(e){return new Set(["the","a","an","and","or","but","in","on","at","to","for","of","with","is","was","are","were","be","been","being","have","has","had","do","does","did","will","would","should","could","may","might","must","can","this","that","these","those"]).has(e)}async indexMessage(e){if(e.deleted)return;const a=this.tokenize(e.content),t={id:`idx_${e.id}`,messageId:e.id,channelId:e.channelId,content:e.content,authorPubkey:e.pubkey,timestamp:e.created_at,tokens:a};await this.searchIndex.put(t)}async bulkIndexMessages(e){const a=e.filter(t=>!t.deleted).map(t=>{const s=this.tokenize(t.content);return{id:`idx_${t.id}`,messageId:t.id,channelId:t.channelId,content:t.content,authorPubkey:t.pubkey,timestamp:t.created_at,tokens:s}});await this.searchIndex.bulkPut(a)}async removeFromIndex(e){await this.searchIndex.delete(`idx_${e}`)}async clearSearchIndex(){await this.searchIndex.clear()}async addSearchHistory(e,a){await this.searchHistory.add({query:e,timestamp:Date.now()/1e3,resultCount:a});const t=await this.searchHistory.count();if(t>50){const s=await this.searchHistory.orderBy("timestamp").limit(t-50).toArray();await this.searchHistory.bulkDelete(s.map(o=>o.id))}}async getSearchHistory(e=10){return await this.searchHistory.orderBy("timestamp").reverse().limit(e).toArray()}async clearSearchHistory(){await this.searchHistory.clear()}}const C=new f;export{C as d};
