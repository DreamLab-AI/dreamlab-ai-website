import{w as S,d as _}from"./xKPZ-4ZK.js";import{B as y}from"./0ZVSoAEn.js";const F=39e3,N=39002,B=9021,M={channels:[],loading:!1,error:null,currentChannel:null},{subscribe:D,set:E,update:o}=S(M);async function G(n,t,r){o(s=>({...s,loading:!0,error:null}));try{const s={kinds:[F]},l=await n.fetchEvents(s),a=Array.from(l),u={kinds:[N]},v=await n.fetchEvents(u),c=Array.from(v),T={kinds:[B],authors:[t]},d=await n.fetchEvents(T),m=Array.from(d),i=[];for(const h of a){const b=O(h,c,m,t,r);b&&i.push(b)}return o(h=>({...h,channels:i,loading:!1,error:null})),i}catch(s){const l=s instanceof Error?s.message:"Failed to fetch channels";throw o(a=>({...a,loading:!1,error:l})),s}}function O(n,t,r,s,l){const a=n.tags.find(e=>e[0]==="d")?.[1];if(!a)return null;const u=n.tags.filter(e=>e[0]==="cohort").map(e=>e[1]);if(!u.some(e=>l.includes(e))&&u.length>0)return null;let c={};try{c=JSON.parse(n.content)}catch{c={}}const d=t.find(e=>e.tags.find(g=>g[0]==="d")?.[1]===a)?.tags.filter(e=>e[0]==="p").map(e=>e[1])||[],m=d.length,i=d.includes(s),h=r.some(e=>e.tags.find(g=>g[0]==="h")?.[1]===a),I=n.tags.find(e=>e[0]==="section")?.[1]||"dreamlab-lobby",A=n.tags.find(e=>e[0]==="visibility")?.[1]||"public",q=n.tags.find(e=>e[0]==="access-type")?.[1]||"gated",w=n.tags.some(e=>e[0]==="encrypted");return!i&&A==="cohort"?null:{id:a,name:c.name||"Unnamed Channel",description:c.about||"",picture:c.picture,cohorts:u,section:I,visibility:A,accessType:q,isEncrypted:w,memberCount:m,createdAt:n.created_at||0,isMember:i,hasRequestPending:h}}function U(n){o(t=>({...t,currentChannel:n}))}function K(){return y(f).currentChannel}let C=null,p=null;function P(){return C||(C=_(f,n=>n.channels.filter(t=>t.isMember))),C}function J(){return p||(p=_(f,n=>n.channels.filter(t=>!t.isMember&&t.visibility==="public"))),p}const X={subscribe:n=>P().subscribe(n)},Y={subscribe:n=>J().subscribe(n)};function k(n){return y(f).channels.filter(r=>r.cohorts.includes(n))}function x(n){return y(f).channels.filter(r=>r.section===n)}function Q(){E(M)}function j(n,t){o(r=>({...r,channels:r.channels.map(s=>s.id===n?{...s,...t}:s)}))}function z(n){o(t=>({...t,channels:t.channels.filter(r=>r.id!==n),currentChannel:t.currentChannel?.id===n?null:t.currentChannel}))}const f={subscribe:D,set:E,update:o,fetchChannels:G,setCurrentChannel:U,getCurrentChannel:K,getChannelsByCohort:k,getChannelsBySection:x,clearChannels:Q,updateChannel:j,removeChannel:z};export{Y as availableChannels,f as channelStore,Q as clearChannels,G as fetchChannels,J as getAvailableChannels,k as getChannelsByCohort,x as getChannelsBySection,K as getCurrentChannel,P as getMemberChannels,X as memberChannels,z as removeChannel,U as setCurrentChannel,j as updateChannel};
