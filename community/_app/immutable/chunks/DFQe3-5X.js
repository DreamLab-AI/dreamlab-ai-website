import{d as k,w as A}from"./xKPZ-4ZK.js";import{n as E}from"./DxD0Wn3l.js";const b={pendingRequests:[],users:[],channels:[],loading:{requests:!1,users:!1,channels:!1},error:null};function C(){const{subscribe:m,set:s,update:a}=A(b);return{subscribe:m,setLoading:(t,e)=>{a(n=>({...n,loading:{...n.loading,[t]:e}}))},setError:t=>{a(e=>({...e,error:t}))},setPendingRequests:t=>{a(e=>({...e,pendingRequests:t,loading:{...e.loading,requests:!1}}))},removePendingRequest:t=>{a(e=>({...e,pendingRequests:e.pendingRequests.filter(n=>n.id!==t)}))},setUsers:t=>{a(e=>({...e,users:t,loading:{...e.loading,users:!1}}))},updateUser:(t,e)=>{a(n=>({...n,users:n.users.map(d=>d.pubkey===t?{...d,...e}:d)}))},setChannels:t=>{a(e=>({...e,channels:t,loading:{...e.loading,channels:!1}}))},addChannel:t=>{a(e=>({...e,channels:[...e.channels,t]}))},updateChannel:(t,e)=>{a(n=>({...n,channels:n.channels.map(d=>d.id===t?{...d,...e}:d)}))},deleteChannel:t=>{a(e=>({...e,channels:e.channels.filter(n=>n.id!==t)}))},reset:()=>s(b)}}const h=C(),F=k(h,m=>{const s=new Map;return m.pendingRequests.forEach(a=>{const t=s.get(a.channelId)||[];s.set(a.channelId,[...t,a])}),s}),T=k(h,m=>{const s=new Map;return m.users.forEach(a=>{a.cohorts.forEach(t=>{const e=s.get(t)||[];s.set(t,[...e,a])})}),s});async function I(m){h.setLoading("requests",!0),h.setError(null);try{const s=E();if(!s)throw new Error("NDK not initialized");const a={kinds:[9021],limit:100},t=await s.fetchEvents(a),e=Array.from(t).map(n=>{const d=n.tags.find(i=>i[0]==="h"),p={id:n.id,kind:n.kind,pubkey:n.pubkey,created_at:n.created_at,tags:n.tags,content:n.content,sig:n.sig};return{id:n.id,pubkey:n.pubkey,channelId:d?.[1]||"",channelName:"",timestamp:n.created_at,event:p}});e.sort((n,d)=>d.timestamp-n.timestamp),h.setPendingRequests(e)}catch(s){console.error("Failed to fetch pending requests:",s),h.setError("Failed to load pending requests"),h.setLoading("requests",!1)}}async function M(m){h.setLoading("users",!0),h.setError(null);try{const s=E();if(!s)throw new Error("NDK not initialized");const[a,t]=await Promise.all([s.fetchEvents({kinds:[0],limit:500}),s.fetchEvents({kinds:[9022],limit:1e3})]),e=Array.from(a),n=Array.from(t),d=new Map;e.forEach(i=>{try{const l=JSON.parse(i.content);d.set(i.pubkey,{pubkey:i.pubkey,name:l.name||l.display_name,cohorts:[],channels:[],joinedAt:i.created_at,lastSeen:i.created_at})}catch(l){console.error("Failed to parse metadata:",l)}}),n.forEach(i=>{const l=d.get(i.pubkey);if(l){const g=i.tags.find(o=>o[0]==="e"),r=i.tags.find(o=>o[0]==="cohort");g?.[1]&&l.channels.push(g[1]),r?.[1]&&!l.cohorts.includes(r[1])&&l.cohorts.push(r[1]),l.lastSeen=Math.max(l.lastSeen||0,i.created_at)}});const p=Array.from(d.values());p.sort((i,l)=>(l.lastSeen||0)-(i.lastSeen||0)),h.setUsers(p)}catch(s){console.error("Failed to fetch users:",s),h.setError("Failed to load users"),h.setLoading("users",!1)}}async function L(m){h.setLoading("channels",!0),h.setError(null);try{const s=E();if(!s)throw new Error("NDK not initialized");const[a,t,e]=await Promise.all([s.fetchEvents({kinds:[40],limit:100}),s.fetchEvents({kinds:[41],limit:100}),s.fetchEvents({kinds:[9022],limit:1e3})]),n=Array.from(a),d=Array.from(t),p=Array.from(e),i=new Map;n.forEach(r=>{try{const o=JSON.parse(r.content),c=r.tags.filter(u=>u[0]==="cohort"),f=c.length>1?c.map(u=>u[1]):c[0]?.[1]?.split(",")||[],y=r.tags.find(u=>u[0]==="visibility"),w=r.tags.find(u=>u[0]==="encrypted"),S=r.tags.find(u=>u[0]==="section"),q=y?.[1]==="cohort"||y?.[1]==="private"?y[1]:"public";i.set(r.id,{id:r.id,name:o.name||"Unnamed Channel",description:o.about||o.description,cohorts:f,visibility:q,encrypted:w?.[1]==="true",section:S?.[1]||"dreamlab-lobby",createdAt:r.created_at,memberCount:0,creatorPubkey:r.pubkey})}catch(o){console.error("Failed to parse channel creation event:",o)}}),d.forEach(r=>{const o=r.tags.find(c=>c[0]==="e");if(o?.[1]){const c=i.get(o[1]);if(c)try{const f=JSON.parse(r.content);c.name=f.name||c.name,c.description=f.about||f.description||c.description}catch(f){console.error("Failed to parse channel metadata:",f)}}});const l=new Map;p.forEach(r=>{const o=r.tags.find(c=>c[0]==="e");if(o?.[1]){const c=l.get(o[1])||new Set;c.add(r.pubkey),l.set(o[1],c)}}),l.forEach((r,o)=>{const c=i.get(o);c&&(c.memberCount=r.size)});const g=Array.from(i.values());g.sort((r,o)=>o.createdAt-r.createdAt),h.setChannels(g)}catch(s){console.error("Failed to fetch channels:",s),h.setError("Failed to load channels"),h.setLoading("channels",!1)}}export{h as adminStore,L as fetchAllChannels,M as fetchAllUsers,I as fetchPendingRequests,F as pendingRequestsByChannel,T as usersByCohort};
